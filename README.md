# Part 1: Compilers crash course

```
In this part we describe different compilation and interpretation pipelines, see the difference between JIT-compilers and AOT-compilers, talk about what is a Virtual machine and Bytecode-interpreter, and how it differs from an AST-interpreter, show examples of native code, and LLVM IR, and other topics.
```

## Lecture 1: Parsers, ASTs, Interpreters and Compilers

- Introduction and course overview
- Parsing pipeline
- Tokenizer, tokens
- Abstract Syntax Trees (AST)
- Static/Compile time vs. Runtime
- Interpreters vs. Compilers
- AST-interpreters (recursive)
- Bytecode-interpreters
- Ahead-of-time (AOT) compilers
- Just-in-time (JIT) compilers
- Transpilers

---

## Lecture 2: AST Interpreters and Virtual Machines

- AST interpreters
- AST explorer
- JavaScript AST example
- Bytecode interpreters
- Stack machine vs. Register machine
- Stack VM bytecode evaluation example
- Compiler explorer
- Java bytecode example
- Python bytecode example
- Register VM bytecode evaluation example

---

## Lecture 3: Compilers: AOT, JIT, Transpiler

- Ahead-of-time (AOT) compiler
- Just-in-time (JIT) compiler
- LLVM
- Intermediate representation (IR)
- Bytecode
- Clang
- x64 Assembly
- AST-transformer (Transpiler)

---

# Part 2: Interpreters: Basic expressions and Variables

```
In this part we start building our programming language, and consider basic expressions, such as numbers, strings, talk about variables, scopes, and lexical environments, control structures, and touching parser generator.
```

## Lecture 4: Eva programming language
